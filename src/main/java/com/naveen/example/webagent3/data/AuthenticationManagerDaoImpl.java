package com.naveen.example.webagent3.data;

import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;

import org.apache.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.naveen.example.webagent3.servlet.RequestInterceptorController;
import com.naveen.example.webagent3.utility.EncryptionDecryptionUtility;
import com.naveen.example.webagent3.utility.StringToNumberConversion;

@Service
public class AuthenticationManagerDaoImpl implements AuthenticationManagerDao {

	@Autowired
	EncryptionDecryptionUtility encryptionDecryptionUtility;

	@Autowired
	StringToNumberConversion stringToNumberConversion;

	private final static String SESSIONNAME = "NAVEENSESSIONID";
	private final static String FORMFREECREDCOOKIE = "formFreeCredCookie";
	private final static String SECRET = "27e799e85ebf430695cd915a29065805";
	private final static int IDLETIMEOUT = 600000;
	private final static int MAXTIMEOUT = 3600000;
	final static Logger logger = Logger.getLogger(AuthenticationManagerDaoImpl.class);

	/*
	 * This method is to validate the existing session cookie and generate or
	 * extend the validity of existing session cookie
	 * 
	 * If cookie type is formFreeCredCookie then session cookie will be created
	 */
	@Override
	public Map<String, String> validateAndCreateSession(String cookie, String cookieType) {
		Boolean isValid = false;
		Map<String, String> sessionObject = new HashMap<String, String>();
		sessionObject.put("validation", "failure");
		// Decrypt the formFreeCredCookie Generated by policy server
		String decryptedString = EncryptionDecryptionUtility.decrypt(cookie, SECRET);
		logger.info("Cookie after decrypted with shared key " + decryptedString);
		String[] tokens = decryptedString.split("&");
		Map<String, String> keyValues = new LinkedHashMap<String, String>();
		for (int i = 0; i < tokens.length; i++) {
			String[] keyValue = tokens[i].split("=");
			keyValues.put(keyValue[0], keyValue[1]);
		}
		String value = keyValues.get("createdTime");
		String userId = keyValues.get("sAMAccountName");
		long timeStampFromCookie = stringToNumberConversion.getNumber(value);
		long presentTimeStamp = System.currentTimeMillis();

		if (cookieType.equalsIgnoreCase(FORMFREECREDCOOKIE)) {
			// do some calculations to check the formFreecredcookie validity
			if (presentTimeStamp - timeStampFromCookie < 3000000) {
				logger.info("FormFreeCredCookie is valid");
				isValid = true;
			}
		} else if (cookieType.equalsIgnoreCase(SESSIONNAME)) {
			// do some calculations to check the session validity
			long lastSessionTime = stringToNumberConversion.getNumber(keyValues.get("lastSessionTime"));
			if (presentTimeStamp - timeStampFromCookie < MAXTIMEOUT
					&& presentTimeStamp - lastSessionTime < IDLETIMEOUT) {
				logger.info("SessionCookie is valid");
				isValid = true;
			}
		}

		if (isValid) {
			// Update the lastSessionTime
			keyValues.put("lastSessionTime", "" + presentTimeStamp);
			keyValues.put("idleTimeOut", "" + IDLETIMEOUT);
			keyValues.put("maxTimeOut", "" + MAXTIMEOUT);
			logger.info("Creating the session cookie with updated lastsessionTime");
			String sessionID = EncryptionDecryptionUtility.encrypt(constructBaseString(keyValues), SECRET);
			logger.info("New session id is generated " + sessionID);
			sessionObject.put("validation", "success");
			sessionObject.put("sessionID", sessionID);
			sessionObject.put("userId", userId);
		} else {
			logger.info("Cookie is invalid and should redirect to login page");
		}

		return sessionObject;
	}

	// This utility method is to construct a base string being used in
	// Encryption utility
	public static String constructBaseString(Map keyValues) {
		String constructedString = "";
		StringBuilder sb = new StringBuilder();
		Set entry = keyValues.entrySet();
		Iterator iterator = entry.iterator();
		while (iterator.hasNext()) {
			Map.Entry<String, String> mapEntry = (Map.Entry<String, String>) iterator.next();
			String key = (String) mapEntry.getKey();
			String value = (String) mapEntry.getValue();
			sb.append(key).append("=").append(value).append("&");
		}
		constructedString = sb.substring(0, sb.length());
		logger.info("Constructed String " + constructedString);
		return constructedString;

	}

}
